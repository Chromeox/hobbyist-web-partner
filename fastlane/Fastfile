# This file contains the fastlane configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

# Lane for setting up certificates and provisioning profiles
lane :setup_certificates do
  desc "Setup certificates and provisioning profiles"
  
  # Use match to sync certificates and provisioning profiles
  match(
    type: "development",
    app_identifier: "com.hobbyist.bookingapp",
    readonly: ENV["CI"] == "true" # Read-only in CI environments
  )
  
  match(
    type: "appstore",
    app_identifier: "com.hobbyist.bookingapp",
    readonly: ENV["CI"] == "true"
  )
  
  UI.success "‚úÖ Certificates and provisioning profiles setup complete"
end

# Lane for building the app
lane :build_app_store do
  desc "Build app for App Store distribution"
  
  # Ensure we have the latest certificates
  setup_certificates
  
  # Increment build number
  increment_build_number(
    xcodeproj: "HobbyistSwiftUI.xcodeproj",
    build_number: latest_testflight_build_number + 1
  )
  
  # Build the app
  build_app(
    scheme: "HobbyistSwiftUI",
    export_method: "app-store",
    output_directory: "./build",
    output_name: "HobbyistSwiftUI.ipa",
    clean: true,
    include_bitcode: false,
    include_symbols: true
  )
  
  UI.success "‚úÖ App Store build complete"
end

# Lane for building TestFlight
lane :build_testflight do
  desc "Build app for TestFlight distribution"
  
  # Ensure we have the latest certificates
  setup_certificates
  
  # Increment build number based on TestFlight
  increment_build_number(
    xcodeproj: "HobbyistSwiftUI.xcodeproj",
    build_number: latest_testflight_build_number + 1
  )
  
  # Build the app
  build_app(
    scheme: "HobbyistSwiftUI",
    export_method: "app-store",
    output_directory: "./build",
    output_name: "HobbyistSwiftUI-TestFlight.ipa",
    clean: true,
    include_bitcode: false,
    include_symbols: true
  )
  
  UI.success "‚úÖ TestFlight build complete"
end

# Enhanced lane for uploading to TestFlight with automation features
lane :upload_testflight do |options|
  desc "Upload app to TestFlight with enhanced automation"
  
  # Pre-upload validation
  unless options[:skip_validation]
    UI.message "üîç Running pre-upload validation..."
    validation_result = sh "./testflight-automation/scripts/pre-upload-validation.sh", error_callback: ->(result) {
      UI.error "‚ùå Pre-upload validation failed with exit code: #{result}"
      next
    }
    UI.success "‚úÖ Pre-upload validation passed"
  end
  
  # Build the app if no IPA provided
  unless options[:skip_build]
    build_testflight
  end
  
  # Upload to TestFlight with retry logic
  upload_with_retry(options)
  
  UI.success "‚úÖ TestFlight upload complete"
  
  # Send notification
  send_upload_notification(options)
end

# Helper lane for upload with retry logic
private_lane :upload_with_retry do |options|
  max_attempts = options[:max_retry_attempts] || 3
  attempt = 1
  
  while attempt <= max_attempts
    begin
      UI.message "üì§ Upload attempt #{attempt}/#{max_attempts}"
      
      pilot(
        ipa: "./build/HobbyistSwiftUI-TestFlight.ipa",
        skip_waiting_for_build_processing: options[:skip_waiting] || true,
        skip_submission: options[:skip_submission] || false,
        distribute_external: options[:distribute_external] || false,
        changelog: options[:changelog] || generate_changelog,
        beta_app_feedback_email: ENV["BETA_FEEDBACK_EMAIL"],
        beta_app_description: "HobbyistSwiftUI alpha version for testing",
        groups: options[:groups] || ["Alpha Testers", "Internal Team"],
        notify_external_testers: options[:notify_external] || false,
        app_platform: "ios",
        distribute_only: options[:distribute_only] || false
      )
      
      UI.success "‚úÖ Upload successful on attempt #{attempt}"
      break
      
    rescue => exception
      UI.error "‚ùå Upload attempt #{attempt} failed: #{exception.message}"
      
      if attempt < max_attempts
        wait_time = calculate_backoff_delay(attempt)
        UI.message "‚è≥ Waiting #{wait_time} seconds before retry..."
        sleep(wait_time)
        attempt += 1
      else
        UI.user_error! "‚ùå Upload failed after #{max_attempts} attempts"
      end
    end
  end
end

# Helper lane to calculate exponential backoff delay
private_lane :calculate_backoff_delay do |attempt|
  base_delay = 30
  max_delay = 300
  delay = [base_delay * (2 ** (attempt - 1)), max_delay].min
  delay
end

# Helper lane to generate changelog from git commits
private_lane :generate_changelog do
  begin
    # Get commits since last tag or last 10 commits
    git_log = changelog_from_git_commits(
      between: [last_git_tag, "HEAD"],
      pretty: "- %s",
      date_format: "short",
      match_lightweight_tag: false,
      merge_commit_filtering: "exclude_merges"
    )
    
    if git_log.empty?
      return "Bug fixes and performance improvements"
    else
      return git_log
    end
  rescue
    return "Bug fixes and performance improvements"
  end
end

# Helper lane to send upload notifications
private_lane :send_upload_notification do |options|
  build_number = get_build_number
  version = get_version_number
  changelog = options[:changelog] || generate_changelog
  
  # Slack notification
  if ENV["SLACK_WEBHOOK_URL"]
    slack(
      message: "üì± New TestFlight build uploaded successfully!",
      success: true,
      channel: ENV["SLACK_CHANNEL"] || "#ios-releases",
      username: "TestFlight Bot",
      icon_emoji: ":rocket:",
      payload: {
        "App" => "HobbyistSwiftUI",
        "Version" => version,
        "Build Number" => build_number,
        "Bundle ID" => "com.hobbyist.bookingapp",
        "Changelog" => changelog.length > 200 ? changelog[0..197] + "..." : changelog,
        "Upload Time" => Time.now.strftime("%Y-%m-%d %H:%M:%S"),
        "Groups" => options[:groups] || ["Alpha Testers", "Internal Team"]
      },
      attachment_properties: {
        color: "good",
        fields: [
          {
            title: "TestFlight Status",
            value: "Processing build...",
            short: true
          },
          {
            title: "Estimated Processing Time",
            value: "5-15 minutes",
            short: true
          }
        ]
      }
    )
  end
  
  # Webhook notification (if configured)
  if ENV["WEBHOOK_URL"]
    begin
      webhook_payload = {
        event: "testflight_upload_success",
        app_name: "HobbyistSwiftUI",
        bundle_id: "com.hobbyist.bookingapp",
        version: version,
        build_number: build_number,
        changelog: changelog,
        timestamp: Time.now.iso8601,
        groups: options[:groups] || ["Alpha Testers", "Internal Team"]
      }
      
      sh "curl -X POST -H 'Content-Type: application/json' -d '#{webhook_payload.to_json}' #{ENV['WEBHOOK_URL']}"
      UI.success "‚úÖ Webhook notification sent"
    rescue => exception
      UI.error "‚ö†Ô∏è Webhook notification failed: #{exception.message}"
    end
  end
end

# Lane for uploading to App Store
lane :upload_app_store do |options|
  desc "Upload app to App Store"
  
  # Build the app if no IPA provided
  unless options[:skip_build]
    build_app_store
  end
  
  # Upload to App Store Connect
  deliver(
    ipa: "./build/HobbyistSwiftUI.ipa",
    skip_metadata: options[:skip_metadata] || false,
    skip_screenshots: options[:skip_screenshots] || false,
    skip_binary_upload: false,
    force: true,
    submit_for_review: options[:submit_for_review] || false,
    automatic_release: options[:automatic_release] || false,
    phased_release: options[:phased_release] || true,
    submission_information: {
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: false,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: "ios",
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_app_type: nil,
      export_compliance_uses_encryption: false
    }
  )
  
  UI.success "‚úÖ App Store upload complete"
  
  # Send notification (optional)
  if ENV["SLACK_WEBHOOK_URL"]
    slack(
      message: "üöÄ App successfully uploaded to App Store!",
      success: true,
      payload: {
        "Build Number" => get_build_number,
        "Version" => get_version_number,
        "Status" => options[:submit_for_review] ? "Submitted for Review" : "Ready for Manual Review"
      }
    )
  end
end

# Lane for complete TestFlight release with full automation
lane :release_testflight do |options|
  desc "Complete TestFlight release process with full automation"
  
  # Validate environment
  ensure_env_vars(
    env_vars: ['MATCH_PASSWORD', 'FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD']
  )
  
  # Run tests before release
  unless options[:skip_tests]
    run_tests(
      scheme: "HobbyistSwiftUI",
      devices: ["iPhone 15 Pro"],
      clean: true
    )
  end
  
  # Upload to TestFlight with enhanced features
  upload_testflight(options)
  
  # Monitor processing status
  unless options[:skip_monitoring]
    monitor_processing_status(options)
  end
  
  UI.success "üéâ TestFlight release complete!"
end

# Lane for automated TestFlight build management
lane :automated_testflight_release do |options|
  desc "Fully automated TestFlight release with all checks and monitoring"
  
  begin
    # Step 1: Pre-flight validation
    UI.header "üîç Step 1: Pre-flight Validation"
    unless options[:skip_validation]
      validation_result = sh "./testflight-automation/scripts/pre-upload-validation.sh --skip-auth"
      UI.success "‚úÖ Pre-flight validation passed"
    end
    
    # Step 2: Increment version if needed
    UI.header "üî¢ Step 2: Version Management"
    if options[:increment_version]
      increment_version_number(version_number: options[:version])
    end
    
    # Step 3: Build and upload
    UI.header "üõ†Ô∏è Step 3: Build and Upload"
    release_testflight(
      skip_tests: options[:skip_tests] || false,
      skip_monitoring: false,
      changelog: options[:changelog],
      groups: options[:groups],
      distribute_external: options[:distribute_external] || false
    )
    
    # Step 4: Update testing groups if specified
    UI.header "üë• Step 4: Testing Group Management"
    if options[:manage_groups]
      manage_testing_groups(options)
    end
    
    # Step 5: Submit for beta review if external distribution
    UI.header "üìù Step 5: Beta Review Submission"
    if options[:distribute_external] && options[:auto_submit_review]
      submit_beta_review(options)
    end
    
  rescue => exception
    UI.error "‚ùå Automated TestFlight release failed: #{exception.message}"
    
    # Send failure notification
    send_failure_notification(exception, options)
    
    # Re-raise the exception
    raise exception
  end
end

# Lane to monitor TestFlight processing status
lane :monitor_processing_status do |options|
  desc "Monitor TestFlight build processing status"
  
  build_number = get_build_number
  timeout = options[:timeout] || 900  # 15 minutes default
  check_interval = options[:check_interval] || 30  # 30 seconds default
  
  UI.message "üï∞Ô∏è Monitoring build processing status for build #{build_number}..."
  
  start_time = Time.now
  
  while (Time.now - start_time) < timeout
    begin
      # Check build status using spaceship
      app = Spaceship::ConnectAPI::App.find("com.hobbyist.bookingapp")
      builds = app.get_builds.select { |build| build.version == build_number }
      
      if builds.any?
        latest_build = builds.first
        processing_state = latest_build.processing_state
        
        UI.message "üîÑ Build #{build_number} status: #{processing_state}"
        
        case processing_state
        when "PROCESSING"
          UI.message "‚è≥ Build still processing... (#{((Time.now - start_time) / 60).round(1)} minutes elapsed)"
        when "VALID"
          UI.success "‚úÖ Build processing complete! Build is ready for testing."
          send_processing_complete_notification(latest_build, options)
          return
        when "INVALID"
          UI.error "‚ùå Build processing failed. Check App Store Connect for details."
          send_processing_failed_notification(latest_build, options)
          return
        else
          UI.message "üîÑ Unknown processing state: #{processing_state}"
        end
      else
        UI.message "‚è≥ Build not yet visible in App Store Connect..."
      end
      
    rescue => exception
      UI.error "‚ö†Ô∏è Error checking processing status: #{exception.message}"
    end
    
    sleep(check_interval)
  end
  
  UI.error "‚è∞ Processing status monitoring timed out after #{timeout / 60} minutes"
end

# Lane for complete App Store release
lane :release_app_store do |options|
  desc "Complete App Store release process"
  
  # Validate environment
  ensure_env_vars(
    env_vars: ['MATCH_PASSWORD', 'FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD']
  )
  
  # Run tests before release
  unless options[:skip_tests]
    run_tests(
      scheme: "HobbyistSwiftUI",
      devices: ["iPhone 15 Pro", "iPad Pro (12.9-inch) (6th generation)"],
      clean: true
    )
  end
  
  # Validate metadata and screenshots
  unless options[:skip_validation]
    precheck(
      app_identifier: "com.hobbyist.bookingapp"
    )
  end
  
  # Upload to App Store
  upload_app_store(options)
  
  UI.success "üéâ App Store release complete!"
end

# Lane for updating metadata only
lane :update_metadata do |options|
  desc "Update App Store metadata without uploading binary"
  
  deliver(
    app_identifier: "com.hobbyist.bookingapp",
    skip_binary_upload: true,
    skip_screenshots: options[:skip_screenshots] || false,
    force: true,
    metadata_path: "./fastlane/metadata"
  )
  
  UI.success "‚úÖ Metadata update complete"
end

# Lane for uploading screenshots
lane :upload_screenshots do
  desc "Upload screenshots to App Store Connect"
  
  deliver(
    app_identifier: "com.hobbyist.bookingapp",
    skip_binary_upload: true,
    skip_metadata: true,
    force: true,
    metadata_path: "./fastlane/metadata"
  )
  
  UI.success "‚úÖ Screenshots upload complete"
end

# Lane for generating screenshots
lane :generate_screenshots do
  desc "Generate app screenshots automatically"
  
  capture_screenshots(
    scheme: "HobbyistSwiftUIUITests",
    output_directory: "./fastlane/screenshots",
    clear_previous_screenshots: true,
    override_status_bar: true,
    devices: [
      "iPhone 15 Pro Max",
      "iPhone 15 Pro", 
      "iPhone SE (3rd generation)",
      "iPad Pro (12.9-inch) (6th generation)",
      "iPad Pro (11-inch) (4th generation)"
    ]
  )
  
  UI.success "‚úÖ Screenshot generation complete"
end

# Lane for running all tests
lane :test do
  desc "Run all unit and UI tests"
  
  run_tests(
    scheme: "HobbyistSwiftUI",
    devices: ["iPhone 15 Pro"],
    clean: true,
    code_coverage: true,
    output_directory: "./test_output"
  )
  
  UI.success "‚úÖ All tests passed"
end

# Lane for code signing setup
lane :setup_code_signing do
  desc "Setup code signing certificates"
  
  # Create/update certificates and provisioning profiles
  match(
    type: "development",
    app_identifier: "com.hobbyist.bookingapp",
    force_for_new_devices: true
  )
  
  match(
    type: "appstore", 
    app_identifier: "com.hobbyist.bookingapp"
  )
  
  UI.success "‚úÖ Code signing setup complete"
end

# Lane for hotfix releases
lane :hotfix_release do |options|
  desc "Create and release hotfix build"
  
  # Validate required parameters
  unless options[:version] && options[:changelog]
    UI.user_error! "‚ùå version and changelog parameters are required for hotfix releases"
  end
  
  # Set version number
  increment_version_number(
    version_number: options[:version]
  )
  
  # Build and upload
  upload_testflight(
    skip_build: false,
    changelog: "[HOTFIX] #{options[:changelog]}"
  )
  
  UI.success "üöë Hotfix release complete for version #{options[:version]}"
end

# Lane for beta testing setup
lane :setup_beta_testing do
  desc "Setup beta testing environment"
  
  # Add beta testers
  pilot(
    skip_submission: true,
    distribute_external: false,
    groups: ["Alpha Testers", "Internal Team"],
    notify_external_testers: false
  )
  
  UI.success "‚úÖ Beta testing setup complete"
end

# Lane for cleanup
lane :cleanup do
  desc "Clean up build artifacts and temporary files"
  
  # Remove build directory
  sh "rm -rf ../build" if File.directory?("../build")
  
  # Clear derived data
  clear_derived_data
  
  UI.success "‚úÖ Cleanup complete"
end

# Error handling
error do |lane, exception|
  UI.error "‚ùå Lane #{lane} failed with exception: #{exception}"
  
  # Send error notification if Slack is configured
  if ENV["SLACK_WEBHOOK_URL"]
    slack(
      message: "‚ùå Fastlane failed in lane: #{lane}",
      success: false,
      payload: {
        "Error" => exception.to_s,
        "Lane" => lane.to_s
      }
    )
  end
end

platform :ios do
  # iOS specific lanes can be added here if needed
  
  desc "iOS platform specific configurations and lanes"
  
  # Lane for updating iOS specific settings
  lane :update_ios_settings do
    desc "Update iOS specific project settings"
    
    # Update project settings
    update_project_provisioning(
      xcodeproj: "HobbyistSwiftUI.xcodeproj",
      target_filter: "HobbyistSwiftUI",
      profile: ENV["sigh_com.hobbyist.bookingapp_appstore_profile-path"],
      code_signing_identity: "iPhone Distribution"
    )
    
    UI.success "‚úÖ iOS settings updated"
  end
  
  # Lane for device registration
  lane :register_devices do
    desc "Register new devices for development"
    
    register_devices(
      devices_file: "./fastlane/devices.txt"
    )
    
    # Update provisioning profiles with new devices
    match(
      type: "development",
      force_for_new_devices: true
    )
    
    UI.success "‚úÖ New devices registered"
  end
end

# Success callback
after_all do |lane|
  UI.success "üéâ Lane #{lane} completed successfully!"
end
